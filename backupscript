#!/bin/bash

SOURCE_BACKUP=/root/data
RESTORE_DIR=/restore
BACKUP_DIR=/backup
BACKUP_DIR_LOG=/backup/log
BACKUP_SNAR_DIR=/backup/snar
BACKUP_DATE=$(date +'%d%m%Y')
BACKUP_TIME=$(date +'%H%M%')
BACKUP_NAME=mytestbackup
BACKUP_FILENAME=${BACKUP_NAME}_${BACKUP_DATE}_${BACKUP_TIME}
BACKUP_FULL_COUNT=2
BACKUP_INCR_COUNT=7

#Проверка директорий бэкап и логов
dirsCheck=("$BACKUP_DIR" "$BACKUP_DIR_LOG" "$BACKUP_SNAR_DIR" "$RESTORE_DIR")
for dir in ${dirsCheck[@]}; do
    if [ ! -d "$dir" ]; then
        mkdir $dir
    fi
done

#Функция поиска старых бэкапов или логов
search_old_backup_or_log() {
    local typeBackup=$1
    local typeFile=$2
    local file_count
    local search_dir

    if [ "$typeFile" == "backup" ]; then
        search_dir=$BACKUP_DIR
        file_count=$(ls $BACKUP_DIR | grep $typeBackup | wc -l)
    elif [ "$typeFile" == "log" ]; then
        search_dir=$BACKUP_DIR_LOG
        file_count=$(ls $BACKUP_DIR_LOG | grep $typeBackup | wc -l)
    elif [ "$typeFile" == "snar" ]; then
        search_dir=$BACKUP_SNAR_DIR
        file_count=$(ls $BACKUP_SNAR_DIR | grep $typeBackup | wc -l)
    fi

    if [ -n "$file_count" ]; then
        if [ "$typeBackup" == "full" ]; then
            if [ "$file_count" -gt $BACKUP_FULL_COUNT ]; then
                find $search_dir -maxdepth 1 -type f -name '*full*' | sort -n | head -n 1
            fi
        elif [ "$typeBackup" == "incr" ]; then
            if [ "$file_count" -gt $BACKUP_INCR_COUNT ]; then
                find $search_dir -maxdepth 1 -type f -name '*incr*' | sort -n | head -n 1
            fi
        #Для SNAR
        elif [ "$typeBackup" == "full" ]; then
            if [ "$file_count" -gt $BACKUP_FULL_COUNT ]; then
                find $search_dir -maxdepth 1 -type f -name '*$BACKUP_FILENAME*' | sort -n | head -n 1
            fi
        fi
    fi
}

#Функция удаления инкрементных файлов
remove_old_file_incr_or_log() {
    local old_file_backup_or_log=$1
    local folder_old_file_backup_or_log=$2
    local result_comparison_date=0
    local result_comparison_time=0

    #Удаляем инкременты бэкапов или логов, созданные до времени старого полного бэкапа или файла лога
    old_file_backup_or_log_date=$(echo $old_file_backup_or_log | awk -F'_' '{print $2}')
    old_file_backup_or_log_time=$(echo $old_file_backup_or_log | awk -F'_' '{print $3}')
    old_file_backup_or_log_full_date="${old_file_backup_or_log_date}${old_file_backup_or_log_time}"

    for old_file in $folder_old_file_backup_or_log/*incr*; do
        [ -f "$old_file" ] || continue
        old_file_date=$(echo $old_file | awk -F'_' '{print $2}')
        old_file_time=$(echo $old_file | awk -F'_' '{print $3}')
        old_file_time_full_date="${old_file_date}${old_file_time}"

        if [ "$old_file_time_full_date" -lt "$old_file_backup_or_log_full_date" ]; then
            rm -f "$old_file"
        fi
    done
}

#Функция создания инкрементных копий
backup_increment() {
    if [ "$(ls $BACKUP_DIR | grep full | wc -l)" -gt 0 ]; then
        #Проверка наличия последнего snar файла
        if [ -f "$BACKUP_SNAR_DIR/last_backup.snar" ]; then
            BACKUP_SNAR=$(cat "$BACKUP_SNAR_DIR/last_backup.snar")
        else
            echo "Файл SNAR для последнего запущенного полного бэкапа не найден"
            exit 1
        fi
        
        #Выполнение инкрементного бэкапа
        tar -g $BACKUP_SNAR -czvf $BACKUP_DIR/${BACKUP_FILENAME}_incr.tar.gz -C $SOURCE_BACKUP . &>$BACKUP_DIR_LOG/${BACKUP_FILENAME}_incr.log
        if [ $? -eq 0 ]; then
            #Находим бэкап или файлы, старше нужных POINT
            old_file_backup_incr=$(search_old_backup_or_log incr backup)
            old_file_log_backup_incr=$(search_old_backup_or_log incr log)

            #Удаляем найденные файлы бэкап или логов
            rm -f $old_file_backup_incr
            rm -f $old_file_log_backup_incr
        fi
    else
        echo "Необходимо сначала выполнить полный бэкап"
        exit 1
    fi
}

#Функция создания полных копий
backup_full() {
    BACKUP_SNAR="$BACKUP_SNAR_DIR/${BACKUP_NAME}_${BACKUP_DATE}_${BACKUP_TIME}_full.snar"
    echo "$BACKUP_SNAR" > "$BACKUP_SNAR_DIR/last_backup.snar"
    
    #Выполнение полного бэкапа
    tar -g $BACKUP_SNAR -czvf $BACKUP_DIR/${BACKUP_FILENAME}_full.tar.gz -C $SOURCE_BACKUP . &>$BACKUP_DIR_LOG/${BACKUP_FILENAME}_full.log
    if [ $? -eq 0 ]; then
        #Находим бэкап или файлы, старше нужных POINT
        old_file_backup_full=$(search_old_backup_or_log full backup)
        old_file_log_backup_full=$(search_old_backup_or_log full log)
        old_file_snar_backup_full=$(search_old_backup_or_log full snar)

        #Удаляем найденные файлы бэкап или логов
        rm -f $old_file_backup_full
        rm -f $old_file_log_backup_full
        rm -f $old_file_snar_backup_full

        count_full_backup=$(ls $BACKUP_DIR | grep full | wc -l)
        if [ "$count_full_backup" -eq "$BACKUP_FULL_COUNT" ]; then
            old_file_backup_full=$(find $BACKUP_DIR -maxdepth 1 -type f -name '*full*' | sort -n | head -n 1)
            old_file_log_backup_full=$(find $BACKUP_DIR_LOG -maxdepth 1 -type f -name '*full*' | sort -n | head -n 1)
            remove_old_file_incr_or_log $old_file_backup_full $BACKUP_DIR
            remove_old_file_incr_or_log $old_file_log_backup_full $BACKUP_DIR_LOG
        fi
    fi
}

#Функция восстановления файлов
restore_data() {

    #Показать доступные бэкапы
    checkBackups=$(ls -1tr "$BACKUP_DIR" | grep -v log | grep -v snar)

    if [ -n "$checkBackups" ]; then
        i=1
        for backup in $checkBackups; do
            echo "$i) $backup"
            ((i++))
        done

        read -p "Введите дату восстановления (в формате 10112025): " restoreDate
        read -p "Введите название файла или его часть для поиска: " restoreData
    else
        echo "Нет доступных бэкапов"
        exit 1
    fi

    #Проверка наличия бэкапа по дате
    if [[ -z $(ls $BACKUP_DIR | grep $restoreDate) ]]; then
        echo "Не найдено бэкапа за эту дату"
        exit 1
    fi

    #Создание массива из файлов бэкапов для его индексации
    mapfile -t files_sorted < <(
        find $BACKUP_DIR -maxdepth 1 -type f | while read -r file; do
            file_name=$(basename "$file")
            file_date=$(echo "$file_name" | awk -F'_' '{print $2}')
            echo "$file_date $file"
        done | sort -r
    )

    #Поиск индекса бэкапа соответствующего дате поиска
    for i in "${!files_sorted[@]}"; do
            file_date=$(echo "${files_sorted[$i]}" | awk -F' ' '{print $1}')
            if [[ "$file_date" == "$restoreDate" ]]; then
                    start_index=$i
                    break
            fi
    done

    #Перебор всех файлов массива до тех пор, пока не найдётся файл в инкременте или не дойдёт до полного бэкапа
    for ((i=$start_index; i<${#files_sorted[@]}; i++)); do
            file_backup=$(echo "${files_sorted[$i]}" | awk -F' ' '{print $2}')
            
            #Процедура поиска файла внутри архивов
            checkFileInBackup=$(tar -tf $file_backup | grep -wi $restoreData)

            if [[ -n $checkFileInBackup ]]; then
                for i in $checkFileInBackup; do
                    tar -xf $file_backup -C $RESTORE_DIR $i
                done

                if [ $? -eq 0 ]; then
                    echo "Данные восстановлены в папку $RESTORE_DIR"
                fi
            else
                echo "Данные для восстановления не найдены"
            fi

            #Проверка нахождения первого full
            if [[ "$file_backup" == *_full* ]]; then
                break
            fi
    done
}

case $1 in
        incr) backup_increment;;
        full) backup_full;;
        restore) restore_data;;
        *) echo "Options: incr, full, restore";;
esac